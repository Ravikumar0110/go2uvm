
# --------------------------------------------------------------------------------
#
# [Name]     
#   VW_DVC_Go2UVM.tcl
#
# [Version]  
#   1.0
# (C) 2014 - 2016 by VerifWorks Pvt Ltd.
# All Rights Reserved.
# www.verifworks.com
# 
# This program is proprietary and confidential information of VerifWorks Pvt Ltd., and 
# may be used and disclosed only as authorized in a license agreement controlling 
# such use and disclosure.

# [Abstract]
#   Create Go2UVM Test (www.go2uvm.org) and SystemVerilog Interface for given RTL TOP level
#
# [Procedure]
#   vw_dvc_main
#
#  # --------------------------------------------------------------------------------

proc print_info { mod_name if_fname go2uvm_test_fname} {
  puts "********************************************"
  puts "* VerifWorks's Verdi VC App: VW_DVC_Go2UVM"
  puts "* Thanks for using VerifWorks products"
  puts "* Visit http://www.verifworks.com for more productivity EDA products "
  puts "* Visit http://www.go2uvm.org to learn more about Open-source Go2UVM Package"
  set t [clock seconds]
  set format_str [clock format $t -format "%Y-%m-%d %H:%M:%S"]
  puts "* Generating SystemVerilog Interface and simple Go2UVM test for module: $mod_name"
  puts "* See file: $if_fname for SystemVerilog Interface"
  puts "* See file: $go2uvm_test_fname for simple Go2UVM test"
  puts "******************************************** \n\n"
}

proc dump_header { LOG } {
  puts $LOG "/********************************************"
  puts $LOG "* VIA App: VW_DVC_Go2UVM"
  puts $LOG "* Automatically generated by VerifWorks's DVC_Go2UVM Verdi Apps "
  puts $LOG "* Thanks for using VerifWorks products"
  puts $LOG "* Visit http://www.verifworks.com for more productivity EDA products "
  puts $LOG "* Visit http://www.go2uvm.org to learn more about Open-source Go2UVM Package"
  set t [clock seconds]
  set format_str [clock format $t -format "%Y-%m-%d %H:%M:%S"]
  puts $LOG "* Generated on   : $format_str"
  puts $LOG "********************************************/ \n\n"
}

proc get_cb_dir_str { npi_dir_str } {
    if { $npi_dir_str == "npiInput" } {
	return "output"
    } elseif { $npi_dir_str == "npiOutput" } {
	return "input"
    } else {
	return "inout"
    } 
}

proc get_mp_dir_str { npi_dir_str } {
    if { $npi_dir_str == "npiInput" } {
	return "input"
    } elseif { $npi_dir_str == "npiOutput" } {
	return "output"
    } else {
	return "inout"
    } 
}


proc vw_dvc_go2uvm { LOG mod_name } {
# go2uvm starts 
  puts $LOG ""
  puts $LOG ""
  puts $LOG ""
  puts $LOG "// Automatically generated from VerifWorks's DVCreate-Go2UVM product"
  puts $LOG "// Thanks for using VerifWorks products, see http://www.verifworks.com for more"
  puts $LOG ""
  puts $LOG "import uvm_pkg::*;"
  puts $LOG "`include \"uvm_macros.svh\""
  puts $LOG "// Import Go2UVM Package"   
  puts $LOG "import vw_go2uvm_pkg::*;"
  puts $LOG "// Use the base class provided by the vw_go2uvm_pkg"
  set class_hdr [format "class %s_test extends go2uvm_base_test;" $mod_name]
  puts $LOG "$class_hdr"
  puts $LOG "  // Create a handle to the actual interface"
  set class_hdr [format "  virtual %s_if vif;" $mod_name]
  puts $LOG "$class_hdr"
  set class_hdr [format "  task reset;" $mod_name]
  puts $LOG "$class_hdr"
  puts $LOG "    `uvm_info (log_id, \"Start of reset\", UVM_MEDIUM)"
  puts $LOG "    `uvm_info (log_id, \"Fill in your reset logic here \", UVM_MEDIUM)"
  puts $LOG "    // this.vif.cb.rst_n <= 1'b0;"
  puts $LOG "    // repeat (5) @ (this.vif.cb);"
  puts $LOG "    // this.vif.cb.rst_n <= 1'b1;"
  puts $LOG "    // repeat (1) @ (this.vif.cb);"
  puts $LOG "    `uvm_info (log_id, \"End of reset\", UVM_MEDIUM)"
  puts $LOG "  endtask : reset"
   
  puts $LOG "  task main ();"
  puts $LOG "    `uvm_info (log_id, \"Start of main\", UVM_MEDIUM)"
  puts $LOG "    `uvm_info (log_id, \"Fill in your main logic here \", UVM_MEDIUM)"
  puts $LOG "    // this.vif.cb.inp_1 <= 1'b0;"
  puts $LOG "    // this.vif.cb.inp_2 <= 22;"
  puts $LOG "    // repeat (5) @ (this.vif.cb);"
  puts $LOG "    `uvm_info (log_id, \"End of main\", UVM_MEDIUM)"
  puts $LOG "  endtask : main"
  set class_hdr [format "endclass : %s_test" $mod_name]
  puts $LOG "$class_hdr"
  puts $LOG ""
  set class_hdr [format "module %s_go2uvm;" $mod_name]
  puts $LOG "$class_hdr"
  puts $LOG "  timeunit 1ns;"
  puts $LOG "  timeprecision 1ns;"
  puts $LOG "  parameter VW_CLK_PERIOD = 10;"
  puts $LOG ""
  puts $LOG "  // Simple clock generator"
  puts $LOG "  bit `VW_CLK ;"
  puts $LOG "  always # (VW_CLK_PERIOD/2) `VW_CLK <= ~`VW_CLK;"
  puts $LOG ""
  puts $LOG "  // Interface instance"
  set class_hdr [format "%s_if %s_if_0 (.*);" $mod_name $mod_name]
  puts $LOG "  $class_hdr"
  puts $LOG ""
  puts $LOG "  // Connect TB clk to Interface instance clk"
  puts $LOG ""
  puts $LOG "  // DUT instance"
  set class_hdr [format "%s %s_0 ();" $mod_name $mod_name]
  puts $LOG "  $class_hdr"
  puts $LOG ""
  puts $LOG ""
  puts $LOG "  // Using VW_Go2UVM"
  set class_hdr [format "%s_test %s_test_0;" $mod_name $mod_name]
  puts $LOG "  $class_hdr" 
  puts $LOG "  initial begin : go2uvm_test"
  set class_hdr [format "  %s_test_0 = new ();" $mod_name]
  puts $LOG "  $class_hdr" 
  puts $LOG "    // Connect virtual interface to physical interface"
  set class_hdr [format "%s_test_0.vif = %s_if_0;" $mod_name $mod_name]
  puts $LOG "    $class_hdr"
  puts $LOG "    // Kick start standard UVM phasing"
  puts $LOG "    run_test ();"
  puts $LOG "  end : go2uvm_test"
  set class_hdr [format "endmodule : %s_go2uvm" $mod_name]
  puts $LOG "$class_hdr"
  puts $LOG ""
# go2uvm ends
}

proc vw_dvc_svi { IF_LOG mod_hdl } {
  set mod_name      [npi_get_str -property npiName -object $mod_hdl]
  puts $IF_LOG "// Generating SystemVerilog interface for module: $mod_name"
  puts $IF_LOG "// ---------------------------------------------------------"

  set port_it [npi_iterate -type npiPort -refHandle $mod_hdl]

  set intf_hdr [format "interface %s_if ();" $mod_name]
  puts $IF_LOG "$intf_hdr"
  set total_num_ports 1

  while { [set port_hdl [npi_scan -iterator $port_it]] != "" } { 
    set port_size [npi_get -property npiSize -object $port_hdl]
    set port_name [npi_get_str -property npiName -object $port_hdl]
    set port_dir  [npi_get_str -property npiDirection -object $port_hdl]

    set total_num_ports [expr $total_num_ports + 1]

        if { $port_size == 1 } {
          set intf_hdr [format "  logic %s;" $port_name]
          puts $IF_LOG "$intf_hdr"
        } else { 
          #multi-bit port
          set port_width [expr $port_size - 1]
          set intf_hdr [format "  logic \[$port_width : 0] %s;" $port_name]
          puts $IF_LOG "$intf_hdr"
        } 
  }
        
  puts $IF_LOG "  // End of interface signals "
  puts $IF_LOG "\n\n  // Start of clocking block definition "

  # All interface signals declared
  # Start clocking block generation
  set cb_line "  clocking cb @(posedge clk);" 
  puts $IF_LOG "$cb_line"
  set port_it [npi_iterate -type npiPort -refHandle $mod_hdl]
  while { [set port_hdl [npi_scan -iterator $port_it]] != "" } { 
    set port_name [npi_get_str -property npiName -object $port_hdl]
    set port_dir  [npi_get_str -property npiDirection -object $port_hdl]
    # Reverse port dir for TB/CB
    set cb_dir_str [get_cb_dir_str $port_dir]
    set cb_line [format "    %s %s;" $cb_dir_str $port_name]
    puts $IF_LOG "$cb_line"
  }
  # End of while  -- clocking block gen
  set cb_line [format "  endclocking : cb"]
  puts $IF_LOG "$cb_line"
  puts $IF_LOG "  // End of clocking block definition "

  # End of clocking block generation
  # Start modport generation

  puts $IF_LOG "\n\n  // Start of modport definition "
  set mp_line "  modport dut_mp (" 
  puts $IF_LOG "$mp_line"
  set port_it [npi_iterate -type npiPort -refHandle $mod_hdl]
  set port_count 1
  while { [set port_hdl [npi_scan -iterator $port_it]] != "" } { 
    set port_name [npi_get_str -property npiName -object $port_hdl]
    set port_dir  [npi_get_str -property npiDirection -object $port_hdl]
    set mp_dir_str [get_mp_dir_str $port_dir]
    set mp_line_tmp [format "    %s %s" $mp_dir_str $port_name]
    set port_count [expr $port_count + 1]
    if {$port_count < $total_num_ports} {
      set mp_line [format "%s ," $mp_line_tmp]
    } else {
      set mp_line [format "%s );" $mp_line_tmp]
    }
    puts $IF_LOG "$mp_line"
  }
  # End of while  -- modport gen
 
  puts $IF_LOG ""
  set intf_hdr [format "endinterface : %s_if" $mod_name]
  puts $IF_LOG "$intf_hdr"

}

proc vw_dvc_main { } {

   set mod_itr [ npi_iterate -type npiInstance -refHandle "" ]
   if { $mod_itr != "" } {
     set mod_hdl [ npi_scan -iterator $mod_itr ]
   }

  if { $mod_hdl } {
	set mod_def_name  [npi_get_str -property npiDefName -object $mod_hdl]
	set mod_name      [npi_get_str -property npiName -object $mod_hdl]
	set mod_full_name [npi_get_str -property npiFullName -object $mod_hdl]
  }

  set op_log_fname [format "%s_go2uvm.sv" $mod_name]
  set vw_if_fname [format "%s_if.sv" $mod_name]
  set LOG [open $op_log_fname "w"]
  set IF_LOG [open $vw_if_fname "w"]
  dump_header $LOG 
  dump_header $IF_LOG 
  print_info $mod_name $vw_if_fname $op_log_fname 
  puts $LOG ""
  vw_dvc_svi $IF_LOG $mod_hdl
  vw_dvc_go2uvm $LOG $mod_name
  close $LOG
  close $IF_LOG
}



debImport "-sv" -f flist
vw_dvc_main
debExit
