
# --------------------------------------------------------------------------------
#
# [Name]     
#   VW_DVC_go2uvm.tcl
#
# [Version]  
#   1.0
#
# [Abstract]
#   Create SystemVerilog Interface for given RTL TOP level
#
# [Procedure]
#   vw_dvc_svi
#
#  # --------------------------------------------------------------------------------

namespace eval vw_dvc {
  variable in_port_names_l []
  variable out_port_names_l []
  variable inout_port_names_l []
}

proc dump_header { LOG } {
  puts $LOG "/********************************************"
  puts $LOG "* VerifWorks Go2UVM App: VW_DVC_Go2UVM"
  puts $LOG "* Automatically generated by VerifWorks's DVC_Go2UVM Riviera Apps "
  puts $LOG "* Thanks for using VerifWorks products"
  puts $LOG "* Visit http://www.verifworks.com for more "
  set t [clock seconds]
  set format_str [clock format $t -format "%Y-%m-%d %H:%M:%S"]
  puts $LOG "* Generated on   : $format_str"
  puts $LOG "********************************************/ \n\n"
}


proc wsplit {string sep} {
    set first [string first $sep $string]
    if {$first == -1} {
      return [list $string]
    } else {
      set tmp_l [string length $sep]
      set left [string range $string 0 [expr {$first-1}]]
      set right [string range $string [expr {$first+$tmp_l}] end]
      return [concat [list $left] [wsplit $right $sep]]
    }
}

proc vw_dvc_svi {LOG top_mod } {
  set mod_name      $top_mod
  puts $LOG "// Generating SystemVerilog interface for module: $mod_name"
  puts $LOG "// ---------------------------------------------------------"

  set in_ports [find object -in -list -path /$top_mod *]
  set out_ports [find object -out -list -path /$top_mod *]
  set inout_ports [find object -inout -list -path /$top_mod *]
  set total_num_ports [expr [llength $in_ports] + [llength $out_ports] + [llength $inout_ports]]

  # Create INPUT port name & size
  # set in_port_names_l []
  set in_port_sizes_l []
  foreach item $in_ports {
    set port_des [describe $item]
    set tmp_s [split $item /]
    set tmp_last_val_index [expr [llength $tmp_s] - 1]
    set tmp_port_name [lindex $tmp_s $tmp_last_val_index]
    lappend ::vw_dvc::in_port_names_l $tmp_port_name

    set tmp_s [wsplit $port_des "\n"]
    set tmp1_s [lindex $tmp_s 0]
    if {[string match *Net* $tmp1_s]} {
      set tmp2_s [wsplit $tmp1_s Net]
      puts "Found Net"
    } elseif {[string match *Logic* $tmp1_s]} {
      set tmp2_s [wsplit $tmp1_s Logic]
      puts "Found Logic"
    } else {
      set tmp2_s [wsplit $tmp1_s Net]
      puts "Found UNKNOWN datatype for port $tmp_port_name treating as Net"
    }
      
    set tmp_last_val_index [expr [llength $tmp2_s] - 1]
    set tmp_port_size [lindex $tmp2_s $tmp_last_val_index]
    # echo "SV: $tmp_port_size"
    if {$tmp_port_size == ""} {
      #echo "Single bit"
      set tmp_port_size { }
    }
    lappend in_port_sizes_l $tmp_port_size
    echo "IN: $tmp_port_name $tmp_port_size"
  }
  # Create OUTPUT port name & size
  set out_port_sizes_l []
  foreach item $out_ports {
    set port_des [describe $item]
    set tmp_s [split $item /]
    set tmp_last_val_index [expr [llength $tmp_s] - 1]
    set tmp_port_name [lindex $tmp_s $tmp_last_val_index]
    lappend ::vw_dvc::out_port_names_l $tmp_port_name

    set tmp_s [wsplit $port_des "\n"]
    set tmp1_s [lindex $tmp_s 0]

    set found_net [string match *Net* $tmp1_s]

    if {$found_net == 1} {
      set tmp2_s [wsplit $tmp1_s Net]
    } elseif {[string match *Logic* $tmp1_s]} {
      set tmp2_s [wsplit $tmp1_s Logic]
    } else {
      set tmp2_s [wsplit $tmp1_s Register]
    }
    set tmp_last_val_index [expr [llength $tmp2_s] - 1]
    set tmp_port_size [lindex $tmp2_s $tmp_last_val_index]
    # echo "SV: $tmp_port_size"
    if {$tmp_port_size == ""} {
      #echo "Single bit"
      set tmp_port_size { }
    }
    lappend out_port_sizes_l $tmp_port_size
    echo "OUT: $tmp_port_name $tmp_port_size"
  }

  # Create INOUT port name & size
  set inout_port_sizes_l []
  foreach item $inout_ports {
    set port_des [describe $item]
    set tmp_s [split $item /]
    set tmp_last_val_index [expr [llength $tmp_s] - 1]
    set tmp_port_name [lindex $tmp_s $tmp_last_val_index]
    lappend ::vw_dvc::inout_port_names_l $tmp_port_name

    set tmp_s [wsplit $port_des "\n"]
    set tmp1_s [lindex $tmp_s 0]
    if {[string match *Net* $tmp1_s]} {
      set tmp2_s [wsplit $tmp1_s Net]
      puts "Found Net"
    } elseif {[string match *Logic* $tmp1_s]} {
      set tmp2_s [wsplit $tmp1_s Logic]
      puts "Found Logic"
    } else {
      set tmp2_s [wsplit $tmp1_s Net]
      puts "Found UNKNOWN datatype for port $tmp_port_name treating as Net"
    }
    set tmp_last_val_index [expr [llength $tmp2_s] - 1]
    set tmp_port_size [lindex $tmp2_s $tmp_last_val_index]
    # echo "SV: $tmp_port_size"
    if {$tmp_port_size == ""} {
      #echo "Single bit"
      set tmp_port_size { }
    }
    lappend inout_port_sizes_l $tmp_port_size
    echo "INOUT: $tmp_port_name $tmp_port_size"
  }

  puts $LOG "// Using VW_CLK as a text macro for clock "
  puts $LOG "// If your clock signal is named other than clk, change the macro below"
  puts $LOG "`define VW_CLK clk"

  set intf_hdr [format "interface %s_if (input logic `VW_CLK);" $mod_name]
  puts $LOG "$intf_hdr"

  set num_in_ports [llength $::vw_dvc::in_port_names_l]
  set cur_port_num 0
  while { $cur_port_num < $num_in_ports } { 
    set port_name [lindex $::vw_dvc::in_port_names_l $cur_port_num]
    if {$port_name == "clk"} {
      # Skip clk signal
      incr cur_port_num
      continue
    }
    set port_size [lindex $in_port_sizes_l $cur_port_num]
    set intf_hdr [format "  logic %s %s;" $port_size $port_name]
    puts $LOG "$intf_hdr"
    incr cur_port_num
  }
        
  set num_out_ports [llength $::vw_dvc::out_port_names_l]
  set cur_port_num 0
  while { $cur_port_num < $num_out_ports } { 
    set port_name [lindex $::vw_dvc::out_port_names_l $cur_port_num]
    set port_size [lindex $out_port_sizes_l $cur_port_num]
    set intf_hdr [format "  logic %s %s;" $port_size $port_name]
    puts $LOG "$intf_hdr"
    set cur_port_num [expr $cur_port_num + 1]
  }
        
  set num_inout_ports [llength $::vw_dvc::inout_port_names_l]
  set cur_port_num 0
  while { $cur_port_num < $num_inout_ports } { 
    set port_name [lindex $::vw_dvc::inout_port_names_l $cur_port_num]
    set port_size [lindex $inout_port_sizes_l $cur_port_num]
    set intf_hdr [format "  logic %s %s;" $port_size $port_name]
    puts $LOG "$intf_hdr"
    set cur_port_num [expr $cur_port_num + 1]
  }
        
  puts $LOG "  // End of interface signals "
  puts $LOG "\n\n  // Start of clocking block definition "

  # All interface signals declared
  # Start clocking block generation
  set cb_line "  clocking cb @(posedge `VW_CLK);" 
  puts $LOG "$cb_line"
  set cur_port_num 0
  while { $cur_port_num < $num_in_ports } { 
    set port_name [lindex $::vw_dvc::in_port_names_l $cur_port_num]
    if {$port_name == "clk"} {
      # Skip clk signal
      incr cur_port_num
      continue
    }
    set cb_line [format "    output %s;" $port_name]
    puts $LOG "$cb_line"
    set cur_port_num [expr $cur_port_num + 1]
  }
        
  set num_out_ports [llength $::vw_dvc::out_port_names_l]
  set cur_port_num 0
  while { $cur_port_num < $num_out_ports } { 
    set port_name [lindex $::vw_dvc::out_port_names_l $cur_port_num]
    set cb_line [format "    input %s;" $port_name]
    puts $LOG "$cb_line"
    set cur_port_num [expr $cur_port_num + 1]
  }
        
  set num_inout_ports [llength $::vw_dvc::inout_port_names_l]
  set cur_port_num 0
  while { $cur_port_num < $num_inout_ports } { 
    set port_name [lindex $::vw_dvc::inout_port_names_l $cur_port_num]
    set cb_line [format "    inout %s;" $port_name]
    puts $LOG "$cb_line"
    set cur_port_num [expr $cur_port_num + 1]
  }
   # End of while  -- clocking block gen

  set cb_line [format "  endclocking : cb"]
  puts $LOG "$cb_line"
  puts $LOG "  // End of clocking block definition "

  # End of clocking block generation
  # Start modport generation

  puts $LOG ""
  set intf_hdr [format "endinterface : %s_if" $mod_name]
  puts $LOG "$intf_hdr"

}

proc vw_dvc_g2u_test {LOG top_mod } {
  set mod_name      $top_mod
  puts $LOG "// Generating Go2UVM Test for module: $mod_name"
  puts $LOG "// ---------------------------------------------------------"
  puts $LOG "" 
  puts $LOG "// Automatically generated from VerifWorks's DVCreate-Go2UVM product"
  puts $LOG "// Thanks for using VerifWorks products, see http://www.verifworks.com for more"
  puts $LOG "" 
  puts $LOG "import uvm_pkg::*;"
  puts $LOG "`include \"vw_go2uvm_macros.svh\""
  puts $LOG "// Import Go2UVM Package"   
  puts $LOG "import vw_go2uvm_pkg::*;"
  puts $LOG ""
  puts $LOG "// Use the base class provided by the vw_go2uvm_pkg"
  set class_hdr [format "class %s_test extends go2uvm_base_test;" $top_mod]
  puts $LOG "$class_hdr"
  puts $LOG "  // Create a handle to the actual interface"
  set class_hdr [format "  virtual %s_if vif;" $top_mod]
  puts $LOG ""
  puts $LOG "$class_hdr"
  set class_hdr [format "  task reset;" $top_mod]
  puts $LOG "$class_hdr"
  puts $LOG "    `uvm_info (log_id, \"Start of reset\", UVM_MEDIUM)"
  puts $LOG "    `uvm_info (log_id, \"Fill in your reset logic here \", UVM_MEDIUM)"
  puts $LOG "    // this.vif.cb.rst_n <= 1'b0;"
  puts $LOG "    // repeat (5) @ (this.vif.cb);"
  puts $LOG "    // this.vif.cb.rst_n <= 1'b1;"
  puts $LOG "    // repeat (1) @ (this.vif.cb);"
  puts $LOG "    `uvm_info (log_id, \"End of reset\", UVM_MEDIUM)"
  puts $LOG "  endtask : reset"
  puts $LOG ""
  puts $LOG "  task main ();"
  puts $LOG "    `uvm_info (log_id, \"Start of main\", UVM_MEDIUM)"
  puts $LOG "    `uvm_info (log_id, \"Fill in your main logic here \", UVM_MEDIUM)"
  puts $LOG "    // this.vif.cb.inp_1 <= 1'b0;"
  puts $LOG "    // this.vif.cb.inp_2 <= 22;"
  puts $LOG "    // repeat (5) @ (this.vif.cb);"
  puts $LOG "    `uvm_info (log_id, \"End of main\", UVM_MEDIUM)"
  puts $LOG "  endtask : main"
  puts $LOG ""
  set class_hdr [format "endclass : %s_test" $top_mod]
  puts $LOG "$class_hdr"
  puts $LOG ""
}


proc vw_dvc_g2u_top_mod {LOG top_mod if_fname test_fname } {
  set mod_name      $top_mod
  puts $LOG "// Generating Go2UVM top module for DUT: $mod_name"
  puts $LOG "// ---------------------------------------------------------"
  puts $LOG "`include \"$if_fname\""
  puts $LOG "`include \"$test_fname\""
  set class_hdr [format "module %s_go2uvm;" $top_mod]
  puts $LOG "$class_hdr"
  puts $LOG "  timeunit 1ns;"
  puts $LOG "  timeprecision 1ns;"
  puts $LOG "  parameter VW_CLK_PERIOD = 10;"
  puts $LOG ""
  puts $LOG "  // Simple clock generator"
  puts $LOG "  bit `VW_CLK ;"
  puts $LOG "  always # (VW_CLK_PERIOD/2) `VW_CLK <= ~`VW_CLK;"
  puts $LOG ""
  puts $LOG "  // Interface instance"
  set if_inst_name [format "%s_if_0" $top_mod]
  set mod_line [format "%s_if %s (.*);" $top_mod $if_inst_name]
  puts $LOG "  $mod_line"
  puts $LOG ""
  puts $LOG "  // Connect TB clk to Interface instance clk"
  puts $LOG ""
  set total_num_ports [expr [llength $::vw_dvc::in_port_names_l] + [llength $::vw_dvc::out_port_names_l] + [llength $::vw_dvc::inout_port_names_l]]

  set all_ports_l []
  foreach item $::vw_dvc::in_port_names_l {
    lappend all_ports_l  $item
  }
  foreach item $::vw_dvc::out_port_names_l {
    lappend all_ports_l  $item
  }
  foreach item $::vw_dvc::inout_port_names_l {
    lappend all_ports_l  $item
  }
  set total_num_ports [llength $all_ports_l]

  puts $LOG "  // DUT instance"
  set mod_line [format "%s %s_0 (" $top_mod $top_mod]
  puts $LOG "  $mod_line"
  set tmp_iter 1
  foreach item $all_ports_l {
    if {$tmp_iter < $total_num_ports} {
      set mod_line [format "    .%s(%s.%s)," $item $if_inst_name $item]
    } else {
      set mod_line [format "    .%s(%s.%s)" $item $if_inst_name $item]
    }
    puts $LOG $mod_line
    incr tmp_iter
  }
  puts $LOG "  );"
  puts $LOG ""
  puts $LOG ""
  puts $LOG "  // Using VW_Go2UVM"
  set mod_line [format "%s_test %s_test_0;" $top_mod $top_mod]
  puts $LOG "  $mod_line" 
  puts $LOG "  initial begin : go2uvm_test"
  set mod_line [format "  %s_test_0 = new ();" $top_mod]
  puts $LOG "  $mod_line" 
  puts $LOG "    // Connect virtual interface to physical interface"
  set mod_line [format "%s_test_0.vif = %s_if_0;" $top_mod $top_mod]
  puts $LOG "    $mod_line"
  puts $LOG "    // Kick start standard UVM phasing"
  puts $LOG "    run_test ();"
  puts $LOG "  end : go2uvm_test"
  set mod_line [format "endmodule : %s_go2uvm" $top_mod]
  puts $LOG "$mod_line"
  puts $LOG ""
}

proc go2uvm {top_mod } {

  set op_if_fname [format "%s_if.sv" $top_mod]
  set op_top_fname [format "%s_go2uvm_top.sv" $top_mod]
  set op_test_fname [format "%s_go2uvm_test.svi" $top_mod]
  set IF_LOG [open $op_if_fname "w"]
  set TOP_LOG [open $op_top_fname "w"]
  set TEST_LOG [open $op_test_fname "w"]
  dump_header $IF_LOG 
  dump_header $TOP_LOG 
  dump_header $TEST_LOG 
  vw_dvc_svi $IF_LOG $top_mod
  vw_dvc_g2u_top_mod $TOP_LOG $top_mod $op_if_fname $op_test_fname
  vw_dvc_g2u_test $TEST_LOG $top_mod

 
  close $IF_LOG
  close $TOP_LOG
  close $TEST_LOG

  puts "Successfully generated Go2UVM TB & Test for module: $top_mod "
  puts "See file: $op_top_fname for Go2UVM code"
  puts "Thanks for using VerifWorks products"
  puts "Visit http://www.verifworks.com for more "
}

